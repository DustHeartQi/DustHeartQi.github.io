[{"title":"urllib2和requests的基本使用","slug":"urllib2和requests的基本使用","date":"2017-07-13T16:41:47.219Z","updated":"2017-07-13T16:46:03.325Z","comments":true,"path":"2017/07/14/urllib2和requests的基本使用/","link":"","permalink":"http://yoursite.com/2017/07/14/urllib2和requests的基本使用/","excerpt":"","text":"urllib不是完整的代码，仅供查询和记忆 123456import urllibword=&#123;&quot;wd&quot;:&quot;python学习&quot;print urllib.urlencode(word)&quot;wd=%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2&quot;print urllib.unquote(&quot;wd=%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2&quot;)wd=python学习 urllib2import urllib2 url1234url = &quot;http://www.baidu.com/s&quot;word = &#123;&quot;wd&quot;:&quot;python学习&quot;&#125;word = urllib.urlencode(word)newurl = url + &quot;? +word 随机添加、修改User-Agent123456789&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;ua_list = [ &quot;Mozilla/5.0 (Windows NT 6.1; ) Apple.... &quot;, &quot;Mozilla/5.0 (X11; CrOS i686 2268.111.0)... &quot;, &quot;Mozilla/5.0 (Macintosh; U; PPC Mac OS X.... &quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS... &quot;]user_agent = random.choice(ua_list) 随机获取代理123456789proxy_list = [ &#123;&quot;http&quot; : &quot;124.88.67.81:80&quot;&#125;, &#123;&quot;http&quot; : &quot;124.88.67.81:80&quot;&#125;, &#123;&quot;http&quot; : &quot;124.88.67.81:80&quot;&#125;, &#123;&quot;http&quot; : &quot;124.88.67.81:80&quot;&#125;, &#123;&quot;http&quot; : &quot;124.88.67.81:80&quot;&#125;]# 随机选择一个代理proxy = random.choice(proxy_list) data发送POST请求时，需要特别注意headers的一些属性：Content-Length: 144： 是指发送的表单数据长度为144，也就是字符个数是144个。X-Requested-With: XMLHttpRequest ：表示Ajax异步请求。Content-Type: application/x-www-form-urlencoded ： 表示浏览器提交 Web 表单时使用，表单数据会按照 name1=value1&amp;name2=value2 键值对形式进行编码。1234567891011formdata = &#123; &quot;type&quot;:&quot;AUTO&quot;, &quot;i&quot;:&quot;i love python&quot;, &quot;doctype&quot;:&quot;json&quot;, &quot;xmlVersion&quot;:&quot;1.8&quot;, &quot;keyfrom&quot;:&quot;fanyi.web&quot;, &quot;ue&quot;:&quot;UTF-8&quot;, &quot;action&quot;:&quot;FY_BY_ENTER&quot;, &quot;typoResult&quot;:&quot;true&quot;&#125;data = urllib.urlencode(formdata) header,headers,cookie1234567891011121314151617181920header = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;&quot;&#125;request.get_header(&quot;User-Agent&quot;)request.add_header(&quot;Connection&quot;,&quot;keep-alive&quot;)opener.addeaders = [(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;)]# addheaders 接受一个列表，里面每个元素都是一个headers信息的元祖,opener将附带headers信息headers = &#123; &quot;Host&quot;:&quot;www.renren.com&quot;, &quot;Connection&quot;:&quot;keep-alive&quot;, &quot;Upgrade-Insecure-Requests&quot;:&quot;1&quot;, &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;, &quot;Accept&quot;:&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;, &quot;Accept-Language&quot;:&quot;zh-CN,zh;q=0.8,en;q=0.6&quot;, # 便于终端阅读，表示不支持压缩文件 # Accept-Encoding: gzip, deflate, sdch, # 重点：这个Cookie是保存了密码无需重复登录的用户的Cookie，这个Cookie里记录了用户名，密码(通常经过RAS加密) &quot;Cookie&quot;: &quot;anonymid=ixrna3fysufnwv; depovince=GW; _r01_=1; JSESSIONID=abcmaDhEdqIlM7riy5iMv; jebe_key=f6fb270b-d06d-42e6-8b53-e67c3156aa7e%7Cc13c37f53bca9e1e7132d4b58ce00fa3%7C1484060607478%7C1%7C1484060607173; jebecookies=26fb58d1-cbe7-4fc3-a4ad-592233d1b42e|||||; ick_login=1f2b895d-34c7-4a1d-afb7-d84666fad409; _de=BF09EE3A28DED52E6B65F6A4705D973F1383380866D39FF5; p=99e54330ba9f910b02e6b08058f780479; ap=327550029; first_login_flag=1; ln_uact=mr_mao_hacker@163.com; ln_hurl=http://hdn.xnimg.cn/photos/hdn521/20140529/1055/h_main_9A3Z_e0c300019f6a195a.jpg; t=214ca9a28f70ca6aa0801404dda4f6789; societyguester=214ca9a28f70ca6aa0801404dda4f6789; id=327550029; xnsid=745033c5; ver=7.0; loginfrom=syshome&quot;&#125; cookie大多数情况下，我们只用CookieJar()，如果需要和本地文件交互，就用 MozillaCookjar() 或 LWPCookieJar()12345import cookielibcookiejar = cookielib.Cooliejar()handler = urllib2.HTTPCookieProssor(cookiejar)opener = urllib2.build_opener(handler)opener.open(&quot;http://www.baidu.com&quot;) cookie写入文件123456filename = &quot;cookie.txt&quot;cookijar = cookielib.MozillaCookiejar(filename)handler = urllib2.HTTPCookieProcessor(cookiejar)opener = urllib2.build_opener(handler)response = opener.open(&quot;http://www.baidu.com&quot;)cookiejar.save() 从文件中获取cookie1234567891011cookiejar = cookielib.MozillaCookiejar()cookiejar.load(&quot;cookie.txt&quot;)handler = urllib2.HTTPCookieProcessor(cookiejar)opener = urllib2.build_opener(handler)response = opener.open(&quot;http://www.baidu.com&quot;)cookieStr = &quot; &quot;for item in cookiejar: cookieStr = cookieStr + item.name + &quot;=&quot; + item.value + &quot;;&quot;## 舍去最后一位的分号print cookieStr[:-1] HTTPPasswordMgrWithDefaultRealm() 密码管理对象 验证 代理 密码HTTPPasswordMgrWithDefaultRealm()类将创建一个密码管理对象，用来保存 HTTP 请求相关的用户名和密码，主要应用两个场景： 验证代理授权的用户名和密码 (ProxyBasicAuthHandler())验证Web客户端的的用户名和密码 (HTTPBasicAuthHandler())12345678910111213user = &quot;test&quot;passwd = &quot;123456&quot;proxyserver = &quot;61.158.163..130:16816&quot;passwdmgr = urllib2.HTPPasswordMgrWithDefaultRealm()passwdmgr.add_password(None,proxyserver,user,passwd)proxyauth_handler = urllib.ProxyBasicAuthHandler(passwdmgr)user = &quot;test&quot;passwd = &quot;123456&quot;webserver = &quot;http://192.168.199.107&quot;passwdmgr = urllib2.HTTPPasswordMgrWithDefaultRealm()passwdmgr.add_password(None,webserver,user,passwd)httpauth_handler = urllib2.HTTPBasicAuthHandler(passwdmgr) handler123http_hander = urllib2.HTTPHandler()https_hander = urllib2.HTTPSHandler()http_handler = urllib2.HTTPHandler(debuglever=1) //将 Debug Log 打开，这样程序在执行的时候，会把收包和发包的报头在屏幕上自动打印出来，方便调试，有时可以省去抓包的工作。 代理123httpproxy_handler = urllib2.ProxyHandler(&#123;&quot;http&quot;:&quot;124.88.67.81:80&quot;&#125;)nullproxy_handler = urllib2.ProxyHandler(&#123;&#125;)httpproxy_handler = urllib2.ProxyHandler(proxy) 验证12proxyauth_handler = urllib2.ProxyBasicAuthHandler(passwdmgr)httpauth_handler = urllib2.HTTPBasicAuthHandler(passwdmgr) cookie:123(import cookielib)handler = urllib2.HTTPCookieProcessor(cookiejar)opener = urllib2.build_opener(handler) opener:12opener = urllib2.build_opener(http_handler)opener.addeaders = [(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;)] //addheaders 接受一个列表，里面每个元素都是一个headers信息的元祖, opener将附带headers信息 request:1234request = urllib2.Request(&quot;http://www.baidu.com&quot;)request = urllib2.Request(url, headers = header)request.add_header(&quot;Connection&quot;,&quot;keep-alive&quot;)request = urllib2.Request(url, data=data, headers=headers) response:1234567response = urllib2.urlopen(&quot;http://www.baidu.com&quot;)response = urllib2.urlopen(request)response = opener.open(request)html = response.read()print html","categories":[],"tags":[]},{"title":"Redis读书笔记","slug":"redis","date":"2017-07-08T01:30:24.937Z","updated":"2017-07-13T16:39:10.010Z","comments":true,"path":"2017/07/08/redis/","link":"","permalink":"http://yoursite.com/2017/07/08/redis/","excerpt":"Redis入门指南前三章读书笔记此笔记的参照书籍为Redis入门指南，笔记只整理了前三章的内容。重点为redis的五中数据类型及其命令。 ###目录[TOC] 设计者：Salvatore Sanfilippo ##特性1.内存存储和持久化 Redis数据库中的所有数据都存储在内存中。由于内存的读写速度远快于硬盘，在一台普通的笔记本电脑上，Redis可以在一秒内读写超过十万个键值。 将数据存储在内存中也有问题，例如，程序退出后内存中的数据会丢失。不过Redis提供了对持久化的支持，即可以将内存中的数据异步写入到硬盘中，同时不影响继续提供服务。 2.功能丰富1）可以为每个键设置生存时间，使得Redis可以作为缓存系统来使用。2）Redis和缓存系统Memcached的优劣：Redis是单线程模型，而Memcached支持多线程，所以在多核服务器上后者性能更高一些。如果需要用到高级的数据类型或是持久化等功能，Redis将会是Memcached很好的替代品。3）作为缓存系统，Redis还可以限定数据占用的最大内存空间，在数据达到空间限制后可以按照一定的规则自动淘汰不需要的键。4）Redis的列表类型键可以用来实现队列，并且支持阻塞式读取，可以很容易地实现一个高性能的有限级队列。 3.特点1）Redis提供了一百多个命令，但是常用的却只有十几个，并且每个命令都很容易记忆2）Redis提供了几十种不同编程语言的客户端库3）Redis使用C语言开发，代码量只有3万多行，这降低了用户通过修改Redis源代码来使之更适合自己项目需要的门槛。4）Redis是开源的。5）包括INCR在内的所有Redis命令都是原子操作。 4.命名要求 Redis对于键的命名并没有强制的要求，但比较好的实践是用“对象类型：对象ID：对象属性”来命名一个键，如使用键user:1:friends来存储ID为1的用户的好友列表。对于多个单词则推荐使用“.”分割。在redis-cli中容易输入，无需使用双引号包裹。","text":"Redis入门指南前三章读书笔记此笔记的参照书籍为Redis入门指南，笔记只整理了前三章的内容。重点为redis的五中数据类型及其命令。 ###目录[TOC] 设计者：Salvatore Sanfilippo ##特性1.内存存储和持久化 Redis数据库中的所有数据都存储在内存中。由于内存的读写速度远快于硬盘，在一台普通的笔记本电脑上，Redis可以在一秒内读写超过十万个键值。 将数据存储在内存中也有问题，例如，程序退出后内存中的数据会丢失。不过Redis提供了对持久化的支持，即可以将内存中的数据异步写入到硬盘中，同时不影响继续提供服务。 2.功能丰富1）可以为每个键设置生存时间，使得Redis可以作为缓存系统来使用。2）Redis和缓存系统Memcached的优劣：Redis是单线程模型，而Memcached支持多线程，所以在多核服务器上后者性能更高一些。如果需要用到高级的数据类型或是持久化等功能，Redis将会是Memcached很好的替代品。3）作为缓存系统，Redis还可以限定数据占用的最大内存空间，在数据达到空间限制后可以按照一定的规则自动淘汰不需要的键。4）Redis的列表类型键可以用来实现队列，并且支持阻塞式读取，可以很容易地实现一个高性能的有限级队列。 3.特点1）Redis提供了一百多个命令，但是常用的却只有十几个，并且每个命令都很容易记忆2）Redis提供了几十种不同编程语言的客户端库3）Redis使用C语言开发，代码量只有3万多行，这降低了用户通过修改Redis源代码来使之更适合自己项目需要的门槛。4）Redis是开源的。5）包括INCR在内的所有Redis命令都是原子操作。 4.命名要求 Redis对于键的命名并没有强制的要求，但比较好的实践是用“对象类型：对象ID：对象属性”来命名一个键，如使用键user:1:friends来存储ID为1的用户的好友列表。对于多个单词则推荐使用“.”分割。在redis-cli中容易输入，无需使用双引号包裹。 ##数据类型 ###字符串类型 1.自增，自减incrby bar 2 //自动增加，增量为2，如果不是整数则出错 &lt;2incrby bar 3 //自动增加，增量为2 &lt;5incr bar //自动增加，增量为1，如果不是整数则出错 &lt;6decrby bar 2decr bar incrbyfloat bar 2.7 //增加指定浮点数 2.添加set key hellomset key1 v1 key2 v2 key3 v3append key “ world!” //追加，有引号是因为出现了空格 3.获取strlen key //返回键值的长度mget key1 key3 4.位操作，一个字节八位（bit）set foo bargetbit foo 0 //返回二进制表示的foo索引为0的二进制的值getbit foo 6 //返回二进制表示的foo索引为6的二进制的值getbit foo 100000 //超出返回0setbit foo 6 0 //设置索引为6的值为0bitcount foo //统计二进制表示中1的个数bitcount foo 0 1 //统计前两个字节中（fo）二进制表示中1的个数 set foo1 barset foo2 barbitop or res foo1 foo2 //结果保存到res中get res e:使用多个字符串类型键存储一个对象post:42:title 第一篇日志post:42:author 小白post:42:time 2012年9月21日post:42:content 今天是星期五，… 实践 1.文章访问量统计：我们为每篇文章使用一个名为post：文章ID：page.view的键来记录文章的访问量。每次访问文章的时候使用INCR命令使用相应的键值递增2.生成自增ID：我们用user：count来存储当前类型对象的数量，没增加一个新对象时都使用INCR命令递增改键的值。3.存储文章数据：我们将一篇博客文章的标题、正文、作者与发布时间等多个元素使用序列化函数转换成一个字符串。字符串类型键还可以存储二进制数据。MessagePack序列化的结果是二进制格式，占用空间更小。 ###散列类型1.命令：hset key field valuehget key fieldhmset key f1 v1 f2 v2 f3 v3 hdel key f1 f2 f3hdel car price hmget key f1 f3hgetall key //获取key键中所有字段和值hkeys key //获取key中所有字段hvals key //获取key中所有值hlen key //获取key中字段数量 hexists key f1 //判断key键中f1字段是否存在hsetnx key field value //nx:if not exists 如果已经存在，不执行任何操作。不存在则写入。hincrby person score 60 e:hset car price 500hset car name BMWhget car namehmget car price namehgetall carhset car model C200hexists car model 实践 1.存储文章数据e：使用一个散列类型键存储一个对象 post:32: title 第一篇日志: author 小白: time 2012年9月11日: content 见天是星期五，… ###列表类型可以实现文章的分页功能 1.命令：lpush key v1 v2 v3rpush key v1 v2 v3lpush numbers 2 3lset numbers 1 7 //在索引值为1的位置添加7linsert numbers after 7 3 //7后面插入3linsert numbers before 2 1 //2前面插入1lpop keyrpop keyrpoplpush lista listb //从lista到listb lrem key count valuelrem numbers -1 2 //从右边开始删除1个2ltrim numbers 1 3 //只留下索引为1 2 3 （1到3）的值 llen keyllen numberslindex numbers 0 //获取number中索引值为0的值 lrange key start stoplrange numbers 0 2lrange numbers -2 -1 实践 存储文章ID列表：我们使用列表类型键posts:list记录文章ID列表，当发布新文章时使用lpush命令把新文章的ID加入这个列表中，另外删除文章时也要记得把列表中的文章ID删除，就像这样：lrem post:list 1 文章id（删除id为&lt;文章id&gt;的文章） 缺点：1）散列类型没有类似字符串类型的mget命令那样可以通过一条命令同时获得多个键的键值的版本，所以对于每个文章ID都需要请求一次数据库，也就都会产生一次往返时延，之后我们会介绍使用管道和脚本来优化这个问题。2）修改文章时，需要修改post:文章ID 中的time字段，还需要按照实际的发布时间重新排列posts:list中的元素顺序，而这一操作相对比较繁琐。3）文章数量较多时访问中间的页面性能较差。 存储评论列表：在博客中如果不允许访客修改自己发表的评论，还可以考虑使用列表类型键存储文章的评论。将一条评论的各个元素序列化成字符串后作为列表类型键中的元素来存储。我们使用列表类型键 post:文章ID:comments 来存储某个文章的所有评论。 ###集合类型 集合类型的常用操作时向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型在Redis内部是使用值为空的散列表（hash table）实现的，所以这些操作的时间复杂度都是O（1）。最方便的是多个集合类型键之间还可以进行并集、交集和差集运算，稍后就会看到灵活运用这一特性带来的便利。 1.命令sadd letters asadd letters a b csrem letters c d smembers letterssdiff seta setb setc //差集sinsert seta setb //交集sunion seta setb //并集 sdiffstore destination keysinterstore destination keysunionstore destination key srandmember letters //随机从集合中获取一个元素srandmember letters 3 实践 对每篇文章使用键名为 post:文章ID:tags 的键存储该篇文章的标签。sadd post:42:tags,闲言碎语，技术文章，Java 找到同时属于“java”、“mysql”、和“redis”这三个标签的文章：三个集合取交集 ###有序集合类型 有序集合类型在某些方面和列表类型有些相似。1）二者都是有序的。2）二者都可以获得某一范围的元素。 但是二者有着很大的区别，这使得他们的应用场景也是不同的。 1）列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度回较慢，所以它更加适合实现如“新鲜事”或“日志”这样很少访问中间元素的应用。2）有序集合类型是使用散列表和跳跃表实现的，所以即使读取位于中间部分的数据速度也会很快（时间复杂度是O（log（N）））。3）列表中不能简单地调整某个元素的位置，但是有序集合可以（通过更改这个元素的分数）。4）有序集合要比列表类型更耗费内存。 1.命令：zadd scoreboard 89 tom 67 peter 100 davidzscore scoreboard tomzrange scoreboard 0 2 zrange scoreboard 0 -1 withscores zrangebyscore scoreboard 80 100 //80 到100之间zrangebyscore scoreboard 80 (100 //不包括100zrangebyscore scoreboard (80 +inf //80以上zcount scoreboard 90 100zrank scoreboard peter //获取peter的排名，升序zrevrank scoreboard peter //降序 zrangebyscore scoreboard 60 +inf limit 1 3 //分数高于60的第二个人开始的3个人。zrenrangebyscore scoreboard 100 0 limit 0 3 //分数小于100 zincrby scoreboard 4 jerry //jerry 加4zincrby socreboard -4 jerry //jerry 减4 实践通过有序集合可以实现文章按照点击量排序。","categories":[],"tags":[]}]